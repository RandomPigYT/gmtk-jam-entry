# This makefile will only run when compiling for the web

PROJ_SRC := $(ROOT_PATH)/$(SRC)
PROJ_OBJ := $(ROOT_PATH)/$(OBJ)
PROJ_BIN := $(ROOT_PATH)/$(BIN)
PROJ_WASM := $(ROOT_PATH)/$(WASM)
PROJ_INCLUDE := $(ROOT_PATH)/$(INCLUDE)

CFLAGS += -Wall -Wextra -ggdb3 -std=gnu23 -O3 -DPLATFORM_WEB -DNDEBUG
LDFLAGS += -s USE_GLFW=3 --preload-file ./

TARGET := $(ROOT_PATH)/index.html

SRCS := $(shell find $(PROJ_SRC) -type  f -name "*.c")
OBJS := $(patsubst $(PROJ_SRC)/%.c, $(PROJ_OBJ)/%.o, $(SRCS))
DEPS := $(patsubst $(PROJ_SRC)/%.c, $(PROJ_OBJ)/%.d, $(SRCS))

ifeq ($(GENERATE_ASM), 1)
	ASMS := $(patsubst $(PROJ_SRC)/%.c, $(PROJ_OBJ)/%.s, $(SRCS))
endif

INCLUDES := $(shell find $(PROJ_INCLUDE) -type f -name "*.h")
INCLUDES += $(shell find $(PROJ_SRC) -type f -name "*.h")
INCLUDES += $(shell find $(ROOT_PATH)/$(SRC)/util -type f -name "*.h")

all: $(TARGET)

$(TARGET): $(OBJS) $(ASMS)
	@echo
	@echo building $(TARGET) in src
	@$(LD) $(CFLAGS) $(OBJS) -o $@ $(LDFLAGS)
	@echo built $(TARGET)

-include $(DEPS)

$(PROJ_OBJ)/%.o: $(PROJ_SRC)/%.c
	@echo building $@
	@$(CC) $(CFLAGS) -MD -MP -c $< -o $@
	@echo built $@
	@echo

$(PROJ_OBJ)/%.s: $(PROJ_SRC)/%.c
	@echo Generating assembly $@
	@$(CC) $(CFLAGS) -S $< -o $@
	@echo Generated $@
	@echo
#ifndef COMMON_CAMERA_H
#define COMMON_CAMERA_H

#include <cglm/include/cglm/cglm.h>

enum com_ProjType {
  com_PROJECTION_NONE = 0,

  com_PERSPECTIVE_PROJECTION,
  com_ORTHOGRAPHIC_PROJECTION,
};

struct com_Camera {
  float fov; // In radians
  float aspect_ratio;

  float near_clipping_plane;
  float far_clipping_plane;

  vec3 position;
  vec3 direction;

  enum com_ProjType proj_type;
};

#endif // COMMON_CAMERA_H
PROJ_SRC := $(ROOT_PATH)/$(SRC)/game
PROJ_OBJ := $(ROOT_PATH)/$(OBJ)/game
PROJ_BIN := $(ROOT_PATH)/$(BIN)
PROJ_INCLUDE := $(ROOT_PATH)/$(INCLUDE)

CFLAGS += -Wall -Wextra -ggdb3 -std=gnu23 -O3 -DHOT_RELOAD
LDFLAGS += 
TARGET := $(PROJ_BIN)/game

SRCS := $(shell find $(PROJ_SRC) -type  f -name "*.c")
OBJS := $(patsubst $(PROJ_SRC)/%.c, $(PROJ_OBJ)/%.o, $(SRCS))
DEPS := $(patsubst $(PROJ_SRC)/%.c, $(PROJ_OBJ)/%.d, $(SRCS))

ifeq ($(GENERATE_ASM), 1)
	ASMS := $(patsubst $(PROJ_SRC)/%.c, $(PROJ_OBJ)/%.s, $(SRCS))
endif

INCLUDES := $(shell find $(PROJ_INCLUDE) -type f -name "*.h")
INCLUDES += $(shell find $(PROJ_SRC) -type f -name "*.h")
INCLUDES += $(shell find $(ROOT_PATH)/$(SRC)/util -type f -name "*.h")

all: $(TARGET)

$(TARGET): $(OBJS) $(ASMS)
	@echo
	@echo building $(TARGET)
	@$(LD) $(CFLAGS) $(OBJS) -o $@ $(LDFLAGS)
	@echo built $(TARGET)

-include $(DEPS)

$(PROJ_OBJ)/%.o: $(PROJ_SRC)/%.c
	@echo building $@
	@$(CC) $(CFLAGS) -MD -MP -c $< -o $@
	@echo built $@
	@echo

$(PROJ_OBJ)/%.s: $(PROJ_SRC)/%.c
	@echo Generating assembly $@
	@$(CC) $(CFLAGS) -S $< -o $@
	@echo Generated $@
	@echo
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>

#include "hotreload.h"
#include "plugin-interface.h"

#ifdef linux

#include <dlfcn.h>
#define PLUG_PATH "bin/libplug.so"

#elif (defined(_WIN32) || defined(WIN32))

#include <windows.h>
#define PLUG_PATH "bin/libplug.dll"

#define dlopen(filename, flags) (void *)LoadLibrary(filename)
#define dlclose(handle) !FreeLibrary(handle)
#define dlerror() "Failed to load DLL. Path: " PLUG_PATH
#define dlsym(handle, symbol) (void *)GetProcAddress(handle, symbol)

#endif

#ifdef HOT_RELOAD

#define X(name, ret, ...) ret (*name)(__VA_ARGS__) = nullptr;
PLUGIN_FUNCTIONS();

#endif

static void *plug = nullptr;

void hotreload_load_plug(void) {
#ifdef HOT_RELOAD
  if (plug) {
    if (dlclose(plug) != 0) {
      fprintf(stderr, "%s\n", dlerror());
      exit(EXIT_FAILURE);
    }
  }

  plug = dlopen(PLUG_PATH, RTLD_NOW);
  if (!plug) {
    fprintf(stderr, "%s\n", dlerror());
    exit(EXIT_FAILURE);
  }

  plug_init = dlsym(plug, "plug_init");
  if (!plug_init) {
    fprintf(stderr, "%s\n", dlerror());
    exit(EXIT_FAILURE);
  }

  plug_pre_reload = dlsym(plug, "plug_pre_reload");
  if (!plug_pre_reload) {
    fprintf(stderr, "%s\n", dlerror());
    exit(EXIT_FAILURE);
  }

  plug_post_reload = dlsym(plug, "plug_post_reload");
  if (!plug_post_reload) {
    fprintf(stderr, "%s\n", dlerror());
    exit(EXIT_FAILURE);
  }

  plug_update = dlsym(plug, "plug_update");
  if (!plug_update) {
    fprintf(stderr, "%s\n", dlerror());
    exit(EXIT_FAILURE);
  }

#endif
}

void hotreload_cleanup(void) {
#ifdef HOT_RELOAD
  assert(plug != nullptr);
  if (dlclose(plug) != 0) {
    fprintf(stderr, "%s\n", dlerror());
    exit(EXIT_FAILURE);
  }
#endif
}
#ifndef HOT_RELOAD_H
#define HOT_RELOAD_H

void hotreload_load_plug(void);
void hotreload_cleanup(void);

#endif // HOT_RELOAD_H
#include "raylib/src/raylib.h"
#include "plugin-interface.h"
#include "hotreload.h"

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#ifdef PLATFORM_WEB

#include <emscripten/emscripten.h>

#endif

#define WIDTH 16
#define HEIGHT 9
#define FACTOR 60

void game_frame() {
  BeginDrawing();

  ClearBackground(CLITERAL(Color){
    GetRandomValue(0, 255),
    GetRandomValue(0, 255),
    GetRandomValue(0, 255),
    255,
  });

  EndDrawing();
}

int main(void) {
  InitWindow(WIDTH * FACTOR, HEIGHT * FACTOR, "Game");
  SetTargetFPS(60);
  hotreload_load_plug();
  plug_init();

#ifdef PLATFORM_WEB

  emscripten_set_main_loop(plug_update, 0, 1);

#endif

#ifndef PLATFORM_WEB
  SetRandomSeed(69);

  while (!WindowShouldClose()) {
    plug_update();

#ifdef HOT_RELOAD
    if (IsKeyDown(KEY_LEFT_CONTROL) && IsKeyDown(KEY_R)) {
      void *state = plug_pre_reload();
      hotreload_load_plug();
      plug_post_reload(state);
    }
#endif
  }

#endif

  return 0;
}
#ifndef PLUG_INTERFACE_H
#define PLUG_INTERFACE_H

// enum plug_callback_mode {
//   PLUG_GLFW_WINDOW_SIZE,
//   PLUG_GLFW_NONE = -1,
// };

//typedef void (*plug_glfw_window_callback)(enum plug_callback_mode, ...);

#define PLUGIN_FUNCTIONS()          \
  X(plug_init, void, void)          \
  X(plug_pre_reload, void *, void)  \
  X(plug_post_reload, void, void *) \
  X(plug_update, void, void)

#ifdef HOT_RELOAD

#define X(name, ret, ...) extern ret (*name)(__VA_ARGS__);
PLUGIN_FUNCTIONS();

#else

#define X(name, ret, ...) ret name(__VA_ARGS__);
PLUGIN_FUNCTIONS();

#endif

#undef X

// extern void (*plug_keyboard_input)(int key, int scancode, int action, int mods);
// extern void (*plug_mouse_position_input)(double xpos, double ypos);
// extern void (*plug_mouse_button_input)(int button, int action, int mods);

#endif // PLUG_INTERFACE_H
PROJ_SRC := $(ROOT_PATH)/$(SRC)/plugin
PROJ_OBJ := $(ROOT_PATH)/$(OBJ)/plugin
PROJ_BIN := $(ROOT_PATH)/$(BIN)
PROJ_INCLUDE := $(ROOT_PATH)/$(INCLUDE)


CFLAGS  += -Wall -Wextra -ggdb3 -std=gnu23 -fPIC -O3
LDFLAGS +=

TARGET := $(PROJ_BIN)/libplug.so

SRCS := $(shell find $(PROJ_SRC) -type  f -name "*.c")
OBJS := $(patsubst $(PROJ_SRC)/%.c, $(PROJ_OBJ)/%.o, $(SRCS))
DEPS := $(patsubst $(PROJ_SRC)/%.c, $(PROJ_OBJ)/%.d, $(SRCS))

ifeq ($(GENERATE_ASM), 1)
	ASMS := $(patsubst $(PROJ_SRC)/%.c, $(PROJ_OBJ)/%.s, $(SRCS))
endif

INCLUDES := $(shell find $(PROJ_INCLUDE) -type f -name "*.h")
INCLUDES += $(shell find $(PROJ_SRC) -type f -name "*.h")
INCLUDES += $(shell find $(ROOT_PATH)/$(SRC)/util -type f -name "*.h")

all: $(TARGET)


$(TARGET): $(OBJS) $(ASMS)
	@echo
	@echo building $(TARGET)
	@$(LD) $(CFLAGS) -shared $(OBJS) -o $@ $(LDFLAGS)
	@echo built $(TARGET)

-include $(DEPS)

$(PROJ_OBJ)/%.o: $(PROJ_SRC)/%.c
	@echo building $@
	@$(CC) $(CFLAGS) -MD -MP -c $< -o $@
	@echo built $@
	@echo

$(PROJ_OBJ)/%.s: $(PROJ_SRC)/%.c
	@echo Generating assembly $@
	@$(CC) $(CFLAGS) -S -masm=intel $< -o $@
	@echo Generated $@
	@echo

#include "plugin.h"
#include <raylib/src/raylib.h>

#ifndef PLATFORM_WEB
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#endif

static struct PluginState *plug_state = nullptr;
static Texture2D tex;

void plug_init(void) {
#ifndef PLATFORM_WEB

  plug_state = malloc(sizeof(*plug_state));
  assert(plug_state != NULL && "Failed to initialize plugin state");

  memset(plug_state, 0, sizeof(*plug_state));

#endif

  tex = LoadTexture("./assets/NewerCampFire_2.png");
}

void *plug_pre_reload(void) {
  return plug_state;
}

void plug_post_reload(void *prev_state) {
  plug_state = prev_state;
}

void plug_update(void) {
  BeginDrawing();
  //ClearBackground((Color){ 24, 24, 24, 255 });
  ClearBackground(RED);
  DrawTexture(tex, 0, 0, WHITE);
  EndDrawing();
}
#ifndef PLUGIN_H
#define PLUGIN_H

struct PluginState {};

void plug_init(void);
void *plug_pre_reload(void);
void plug_post_reload(void *prev_state);
void plug_update(void);

#endif // PLUGIN_H
#ifndef UTIL_ARENA_H
#define UTIL_ARENA_H

#include <stddef.h>
#include <stdlib.h>
#include <assert.h>

#define arena_save(arena, r)      \
  do {                            \
    (*(r)) = (arena).base_offset; \
  } while (0)

#define arena_restore(arena, r) \
  do {                          \
    (arena)->base_offset = (r); \
  } while (0)

typedef size_t ArenaSaveState;

struct Arena {
  void *block;
  size_t base_offset;
  size_t size;
};

struct Arena arena_create(size_t size);
void *arena_alloc(struct Arena *arena, size_t size);
void arena_free(struct Arena *arena);
void arena_resize(struct Arena *arena, size_t size);

#ifdef UTIL_ARENA_H_IMPLEMENTATION

struct Arena arena_create(size_t size) {
  struct Arena a = { 0 };

  a.block = malloc(size);
  assert(a.block != NULL && "Failed to allocate memory");

  a.size = size;
  a.base_offset = 0;

  return a;
}

void *arena_alloc(struct Arena *arena, size_t size) {
  assert(arena->block != NULL && "Tried to allocate to NULL arena");

  void *allocated = (char *)arena->block + arena->base_offset;

  size_t tmp = arena->base_offset + size;
  if (tmp >= arena->size) {
    return NULL;
  }
  arena->base_offset = tmp;

  return allocated;
}

void arena_resize(struct Arena *arena, size_t size) {
  arena->block = realloc(arena->block, size);
  assert(arena->block != NULL && "Failed to allocate memory");

  arena->size = size;
}

void arena_free(struct Arena *arena) {
  free(arena->block);
  arena->base_offset = 0;
  arena->size = 0;
}

#endif // UTIL_ARENA_H_IMPLEMENTATION
#endif // UTIL_ARENA_H
#pragma once
#ifndef UTIL_DYNAMIC_ARRAY
#define UTIL_DYNAMIC_ARRAY

#include <assert.h>
#include <string.h>

#define DA_TYPE(type)  \
  struct {             \
    type *items;       \
    uint64_t count;    \
    uint64_t capacity; \
  }

#define DA_TYPE_ARRAY(type, length) \
  struct {                          \
    type (*items)[(length)];        \
    uint64_t count;                 \
    uint64_t capacity;              \
  }

#define DA_INIT_CAPACITY 8
#define DA_GROW_FACTOR 2

#define DA_AT(arr, index)                                     \
  (*({                                                        \
    assert((arr).items != NULL && "Cannot index null array"); \
    assert((index) < (arr).count && "Invalid index");         \
    &(arr).items[(index)];                                    \
  }))

#define DA_APPEND(arr, item)                                            \
  do {                                                                  \
    if ((arr)->count >= (arr)->capacity) {                              \
      (arr)->capacity = (arr)->capacity == 0                            \
                          ? DA_INIT_CAPACITY                            \
                          : DA_GROW_FACTOR * (arr)->capacity;           \
      (arr)->items =                                                    \
        realloc((arr)->items, (arr)->capacity * sizeof(*(arr)->items)); \
      assert((arr)->items != NULL && "Failed to allocate memory");      \
    }                                                                   \
    (arr)->items[(arr)->count++] = (item);                              \
  } while (0)

#define DA_APPEND_NO_ASSIGN(arr)                                        \
  do {                                                                  \
    if ((arr)->count >= (arr)->capacity) {                              \
      (arr)->capacity = (arr)->capacity == 0                            \
                          ? DA_INIT_CAPACITY                            \
                          : DA_GROW_FACTOR * (arr)->capacity;           \
      (arr)->items =                                                    \
        realloc((arr)->items, (arr)->capacity * sizeof(*(arr)->items)); \
      assert((arr)->items != NULL && "Failed to allocate memory");      \
    }                                                                   \
    (arr)->count++;                                                     \
  } while (0)

#define DA_FREE(arr)     \
  do {                   \
    free((arr)->items);  \
    (arr)->items = NULL; \
    (arr)->count = 0;    \
    (arr)->capacity = 0; \
  } while (0)

// Does not work if the type is an array
#define DA_POP(arr, index)                                                    \
  ({                                                                          \
    assert((arr)->count != 0 && "Attempted to pop from empty dynamic array"); \
    assert((index) < (arr)->count && "Invalid index");                        \
                                                                              \
    typeof(*(arr)->items) da_macro_item;                                      \
    memcpy(&da_macro_item, &(arr)->items[(index)], sizeof(*(arr)->items));    \
                                                                              \
    if ((index) == (arr)->count - 1) {                                        \
      (arr)->count--;                                                         \
                                                                              \
    } else {                                                                  \
      memmove(&((arr)->items[(index)]), &((arr)->items[(index) + 1]),         \
              ((arr)->count - (index) - 1) * sizeof(*(arr)->items));          \
      (arr)->count--;                                                         \
    }                                                                         \
                                                                              \
    da_macro_item;                                                            \
  })

#endif // UTIL_DYNAMIC_ARRAY
#pragma once
#ifndef UTIL_FILE_IO_H
#define UTIL_FILE_IO_H

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <limits.h>
#include <stdint.h>

// Compatible with Windows
char *fio_read_file(const char *path);

#define UTIL_FILE_IO_IMPLEMENTATION
#ifdef UTIL_FILE_IO_IMPLEMENTATION

char *fio_read_file(const char *path) {
  FILE *f = fopen(path, "rb");
  if (!f) {
    fprintf(stderr, "[ERROR]: Failed to open file %s: ", path);
    perror(NULL);

    return NULL;
  }

  struct stat s;
  fstat(fileno(f), &s);

  uint64_t size = s.st_size;
  char *buf = malloc(size + 1);

  fread(buf, 1, size, f);
  buf[size] = 0;

  fclose(f);

  return buf;
}

#endif // UTIL_FILE_IO_IMPLEMENTATION

#endif // UTIL_FILE_IO_H
#ifndef UTIL_THREAD_POOL_H
#define UTIL_THREAD_POOL_H

#include "dynamic_array.h"

#include <pthread.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <unistd.h>

typedef void *(*tp_JobCallback)(void *input);
typedef uint64_t tp_JobHandle;

struct tp_Job {
  tp_JobHandle handle;

  tp_JobCallback job;

  void *in;
  void *out;
};

struct tp_ThreadPool {
  pthread_t *pool;
  uint32_t count;

  struct {
    DA_TYPE(struct tp_Job) job_queue;
    pthread_mutex_t job_mutex;
  };

  struct {
    uint64_t handle_counter;
    pthread_mutex_t handle_counter_mutex;
  };

  struct {
    DA_TYPE(struct tp_Job) completed;
    pthread_mutex_t completed_mutex;
  };

  struct {
    bool should_exit;
    pthread_mutex_t should_exit_mutex;
  };
};

// Returns a pointer to a struct tp_ThreadPool allocated on the heap.
struct tp_ThreadPool *tp_create_pool(uint32_t num_threads);

tp_JobHandle tp_add_job(struct tp_ThreadPool *pool, tp_JobCallback job,
                        void *input);

void *tp_wait_job(struct tp_ThreadPool *pool, tp_JobHandle handle);

// Takes ownership of pool and frees it.
// if pool == NULL, tp_free_pool does nothing.
void tp_free_pool(struct tp_ThreadPool *pool);

//#define UTIL_THREAD_POOL_IMPLEMENTATION
#ifdef UTIL_THREAD_POOL_IMPLEMENTATION

void *tp_worker(void *p) {
  struct tp_ThreadPool *pool = p;

  bool should_exit;

  do {
    pthread_mutex_lock(&pool->should_exit_mutex);
    should_exit = pool->should_exit;
    pthread_mutex_unlock(&pool->should_exit_mutex);

    if (should_exit) {
      break;
    }

    struct tp_Job job = { 0 };

    pthread_mutex_lock(&pool->job_mutex);

    bool has_job = false;
    if (pool->job_queue.count != 0) {
      job = DA_POP(&pool->job_queue, 0);
      has_job = true;
    }

    pthread_mutex_unlock(&pool->job_mutex);

    if (has_job) {
      job.out = job.job(job.in);

      pthread_mutex_lock(&pool->completed_mutex);
      DA_APPEND(&pool->completed, job);
      pthread_mutex_unlock(&pool->completed_mutex);
    }

  } while (1);

  return NULL;
}

struct tp_ThreadPool *tp_create_pool(uint32_t num_threads) {
  struct tp_ThreadPool *pool = calloc(1, sizeof(*pool));
  assert(pool != NULL && "Failed to allocate memory");

  pool->count = num_threads;
  pool->pool = malloc(pool->count * sizeof(*pool->pool));
  assert(pool->pool != NULL && "Failed to allocate memory");

  pthread_mutex_init(&pool->job_mutex, NULL);
  pthread_mutex_init(&pool->completed_mutex, NULL);

  pthread_mutex_init(&pool->handle_counter_mutex, NULL);

  pool->should_exit = false;
  pthread_mutex_init(&pool->should_exit_mutex, NULL);

  for (uint32_t i = 0; i < pool->count; i++) {
    errno = pthread_create(&pool->pool[i], NULL, tp_worker, pool);
    if (errno != 0) {
      fprintf(stderr, "Failed to create thread: %s\n", strerror(errno));

      pthread_mutex_lock(&pool->should_exit_mutex);
      pool->should_exit = true;
      pthread_mutex_unlock(&pool->should_exit_mutex);

      free(pool->pool);
      free(pool);
      return NULL;
    }
  }

  return pool;
}

tp_JobHandle tp_add_job(struct tp_ThreadPool *pool, tp_JobCallback job,
                        void *input) {
  pthread_mutex_lock(&pool->handle_counter_mutex);
  struct tp_Job j = {
    .handle = pool->handle_counter++,
    .job = job,
    .in = input,
    .out = NULL,
  };
  pthread_mutex_unlock(&pool->handle_counter_mutex);

  pthread_mutex_lock(&pool->job_mutex);
  DA_APPEND(&pool->job_queue, j);
  pthread_mutex_unlock(&pool->job_mutex);

  return j.handle;
}

void *tp_wait_job(struct tp_ThreadPool *pool, tp_JobHandle handle) {
  for (;;) {
    pthread_mutex_lock(&pool->completed_mutex);

    for (uint64_t i = 0; i < pool->completed.count; i++) {
      struct tp_Job *j = &DA_AT(pool->completed, i);

      if (j->handle == handle) {
        void *output = j->out;

        DA_POP(&pool->completed, i);

        pthread_mutex_unlock(&pool->completed_mutex);
        return output;
      }
    }

    pthread_mutex_unlock(&pool->completed_mutex);
  }
}

void tp_free_pool(struct tp_ThreadPool *pool) {
  if (pool == NULL) {
    return;
  }

  pthread_mutex_lock(&pool->should_exit_mutex);
  pool->should_exit = true;
  pthread_mutex_unlock(&pool->should_exit_mutex);

  for (uint32_t i = 0; i < pool->count; i++) {
    errno = pthread_join(pool->pool[i], NULL);
  }

  free(pool->pool);
  DA_FREE(&pool->job_queue);
  DA_FREE(&pool->completed);

  pthread_mutex_destroy(&pool->job_mutex);
  pthread_mutex_destroy(&pool->completed_mutex);
  pthread_mutex_destroy(&pool->should_exit_mutex);
  pthread_mutex_destroy(&pool->handle_counter_mutex);

  free(pool);
}

#endif // UTIL_THREAD_POOL_IMPLEMENTATION

#endif // UTIL_THREAD_POOL_H
